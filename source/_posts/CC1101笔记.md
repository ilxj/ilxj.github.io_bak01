---
title: CC1101笔记
date: 2017-03-26 00:38:11
tags: [无线,433MHZ,cc1101]
categories: 射频
---
- - -
# 产品描述
## 工作频段
**CC1100: **400-464 MHz and 800-928MHz 
**CC1101:** 387-464 MHz and 779-928MHz
## 芯片引脚

![cc1101引脚](http://upload-images.jianshu.io/upload_images/1736256-bf9e764fcd560a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
<!--more-->
### 引脚说明
---
|引脚编号  | 引脚名  |引脚类型|  描述
|----|----|----|----|
|1|  SCLK  |数字输入  |连续配置接口，时钟输入
|2|  SO(GD01)| 数字输出  |连续配置接口，数据输出当 CSn 为高时为可选的一般输出脚
|3 | GDO2 | 数字输出 | 一般用途的数字输出脚：**1>**测试信号；**2>**FIFO 状态信号;**3>**时钟输出，从 XOSC 向下分割;**4>**连续输入 TX 数据
|4 | DVDD | 功率（数字）|  数字 I/O 和数字中心电压调节器的 1.8V-3.6V 数字功率供给输出
|5| DCOUPL| 功率（数字）|  对退耦的 1.6V-2.0V 数字功率供给输出;**注意：这个引脚只对 CC2500 使用。不能用来对其他设备提供供给电压**
|6|  GDO0(ATEST)|数字 I/O | 一般用途的数字输出脚：**1>** 测试信号;**2>**FIFO 状态信号;**3>**时钟输出，从 XOSC 向下分割;**4>**连续输入 TX 数据;**5>**也用作原型/产品测试的模拟测试 I/O
|7 | CSn|  数字输入 | 连续配置接口，芯片选择
|8 | XOSC_Q1| 模拟 I/O|  晶体振荡器脚 1，或外部时钟输入
|9  |AVDD  |功率（模拟）|  1.8V-3.6V 模拟功率供给连接
|10|  XOSC_Q2| 模拟 I/O|  晶体振荡器脚
|11|  AVDD|  功率（模拟）|  1.8V-3.6V 模拟功率供给连接
|12 | RF_P | RF I/O | 接收模式下对 LNA 的正 RF 输入信号发送模式下对 LNA 的正 RF 输出信号
|13  |AVDD | RF I/O | 接收模式下对 LNA 的负 RF 输入信号发送模式下对 LNA 的负 RF 输出信号
|14|  AVDD  |功率（模拟）|  1.8V-3.6V 模拟功率供给连接
|15|  AVDD  |功率（模拟）|  1.8V-3.6V 模拟功率供给连接
|16|  GND | 地(模拟) | 模拟接地
|17|  RBIAS|  模拟 I/O | 参考电流的外部偏阻器
|18 | DGUARD| 功率（数字）|  对数字噪声隔离的功率供给连接
|19|  GND  |地（数字）|  数字噪声隔离的接地
|20|  SI|  数字输入 | 连续配置接口，数据输入
## 通讯方式以及配置方式---SPI
- CC1101通过4线SPI兼容接口（MOSI,MISO,SCLK和CSn）进行配置，**CC1101作为从设备**。
这个接口同时用作读写缓冲器数据。
SPI接口上所有的数据传送都是先传送 **MSB**

>**拓展知识:**
**MSB:**高位前导
**LSB:**低位前导。
**big endian（大端）**是指低地址存放最高有效字节（MSB），
**little endian（小端）**则是低地址存放最低有效字节（LSB）

### SPI 读写注意事项
- SPI接口上的所有传送都是以一个头字节（header byte）开始包含以下：
 - 一个**读写位(R/W)：**在读操作中该位置1，在写操作中该位置0；
 - 一个**(突发(burst access)访问位(B)**
 - **6位地址位(A5~A0)**。
- 在SPI总线上传输数据时，CSn脚必须保持低电平。如果在发送头字节或者读写寄存器时CSn拉高，传送将被取消
- 当 CSn 变低，在开始转换头字节之前，MCU必须等待，直到 MISO 脚变低。这表明电压调制器已经稳定，晶体正在运作中。除非芯片处在 SLEEP 或 XOFF 状态，MISO 脚在 CSn变低之后总会立即变低。

#### **芯片状态字节**
-  当头字节在 SPI 接口上被写入时，芯片状态字节在 MISO 脚上被 CC1100 写入。状态字节
包含关键状态信号，对 MCU 是有用的。**(7)位**是 CHIP_RDYn 信号。在 SCLK 的在第一个正边缘之前，这个信号必须变低。CHIP_RDYn 信号表明晶体正处于工作中，调节数字供给电压是稳定的。
- 状态字节中的**(6:4 )**位由状态值组成。这个值反映了芯片的状态。当使 XOSC 空闲并使数字中心的能量开启，所有其他模块处于功率降低状态。只有芯片处于此状态时，频率和信道配置才能被更新。当芯片处于接收模式时，RX状态是活动的。同样地，当芯片处于传输模式时，TX 状态是活动的。
- 状态字节中的后四位**(3:0)**包含FIFO_BYTES_AVAILABLE。为了进行读操作，这个区域包含可从 RX FIFO 读取的字节数。为了进行写操作，这个区域包含可写入 TX  FIFO的字当FIFO_BYTES_AVAILABLE=15，15 或者更多的字节是可用/自由的。
![状态字节概要](http://upload-images.jianshu.io/upload_images/1736256-043836467cbc7d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 寄存器访问
- **CC1101 配置寄存器地址: ** 0x00到0x2E
- 所有的配置寄存器均能读和写。读/写位控制寄存器是读或者写。当对寄存器写时，每当一个待写入的数据字节传输到 SI脚时，状态字节将被送至 SO 脚。
- 通过在地址头设置突发位，连续地址的寄存器能高效地被访问。这个地址在内部计数器内设置起始地址。每增加一个新的字节（每8 个时钟脉冲），计数器值增加 1。突发访问，不管是读访问还是写访问，必须通过设置CSn 为高来终止。
- 对 0x30-0x3D 间的地址来说，突发位用以在**状态寄存器**和**命令选通**间选择。状态寄存器只读。突发读取对状态寄存器是不可取的，故它们每次只能被读一个。
**burst位置1：**选择状态寄存器；
**burst置0：**选择命令选通（command strobes）;

### 命令选通(command strobes)
-  命令选通可以看做是CC1101的一个单字节指令。
通过寻址一个命令选通寄存器，将启动内部序列。
这些命令用来**禁止晶振**，**使能接收**，**使能无线唤醒** 等；
- 命令选通寄存器的访问和一个寄存器的写操作一样，但没有数据被传输。就是说，只有 R/W 位（置为 0）突发访问（置为 0）和六个地址位（0x30 和 0x3D 之间）被写。一个命令滤波可能在任何其他 SPI 访问之后，而不需要将 CSn 拉至高电平。命令选通立即被执行，当 CSn 高时 SPWD 和 SXOFF 命令被执行是例外。

### FIFO访问
- 64 字节 TX FIFO 和 64 字节 RX FIFO 通过0x3F 被访问。
 - 读/写位为 0 时，TX FIFO被访问。
 - 读/写位为 1 时，RX FIFO 被访问。
- TX FIFO 是只写的，而 RX FIFO 是只读的。
- 突发位用来决定 FIFO 访问是单字节还是突发访问。
 - 单字节访问方式期望地址的突发位为 0 的头字节和一个数据字节。在数据字节之后跟随一个新的头字节，因此，CSn 继续保持低。
 - 突发访问方式允许一地址字节，然后是连续的数据字节，直到通过设置 CSn 为高来关断访问。
   -  0x3F : 单字节访问 TX FIFO
   - 0x7F : 突发访问 TX FIFO
   - 0xBF : 单字节访问 RX FIFO
   - 0XFF : 突发访问 RX FIFO

### PATABLE 访问
- **0x3E**地址用来访问 PATABLE。PATABLE用来选择 PA 能量控制设置。在接收此地址之后，SPI 等待至少 8 个字节。通过控制PATABLE，能实现可控的 PA 能量上升和下降，减少的带宽的 ASK 调制整型也如此。
- PATABLE 是一个 8 字节表，定义了 PA 控制设 置 ， 为 8 个 PA 功 率 值 （ 由FRENDO.PA_POWER 的 3 个位的值所选择）的每一个所使用。这个表从最低位（0）到最高位（7）可读和写，一次一位。一个索引计数器用来控制对这个表的访问。每读出或写入表中的一个字节，计数器就加 1。当 CSn 为高时，计数值置为最小值。当达到最大值时，计数器由零重新开始计数。
- 对 PATABLE 的访问是单字节或者突发访问，由突发位决定。当使用突发访问时，索引计数器的值增加；达到7时重新从0开始。读/写位控制访问是写访问（R/W=0）或者读访问(R/W=1)。
- 如果一字节被写入 PATABLE，且这个值将要被读出，那么，为了设置索引计数器的值重为 0，CSn 必须在读访问之前置为高。注意，当 PATABLE 进入休眠状态时，所存储的内容会丢失，特别是第一个字节（索引
为 0）。

### 基本控制和状态脚
- CC1101有2个专用配置脚（GDO0和GDO2）和一个共用脚（GDO1）可以向控制软件输出有用的内部状态信息。这些脚可以用来向MCU产生中断。
- GDO1和SPI的SO引脚共用。
 - GDO1/SO的默认设置时3态输出。通过选择任何编程选项，GDO1/SO将变为普通引脚。当CSn拉低，该引脚将始终作为普通的SO功能引脚。
- 在同步和异步串行模式，在发送模式下，GDO0引脚将作为串行TX数据输入引脚。
- GDO0也可以用作片上模拟温度传感器。通过外部ADC测量GDO0脚的电压，可以计算出温度。温度传感器的详细说明见18页的Section 4.7。通过默认的PTEST寄存器设置（0x7F），如果频率合成器被允许温度传感器的的输出时可用的。（例如：MANCAL，FSTXON，RX和 TX状态）在IDLE状态向PTEST寄存器写入0xBF允许模拟温度传感器是必要的。离开IDLE状态之前，必须恢复PTEST寄存器为默认值（0x7F）。

### 数据包处理的硬件支持
#### 发送模式下
>数据包的处理者可以配置增加下面的元素到TX FIFO中的数据包存储

- 一个可编程数量的前导字节；
-  两字节同步字，可复制为4字节同步字。只插入前导字节或者同步字节是不可能的；
- 一个覆盖数据区域的CRC校验计算。 
>推荐设置4字节前导和4字节同步字，除了500k波特率时推荐使用8字节前导。另外，在数据区域和附加的2字节CRC校验，以下可以被执行
 - 使用PN9序列Whitening数据。 
 - 通过使用交叉和编码数据（卷积编码）前向纠错。

#### 接收模式下
>数据包处理支持将是解构数据包，（如使能）以下可以被执行

- 前导检测
- 同步字检测
- CRC计算和CRC检查
- 一个字节地址检测
- 包长度检查（根据设置的最大长度检查长度字节）
- 反Whitening（如果使能）
- 反交叉和解码( 如果使能 )
另外，RSSI（接收信号强度指示）、LQI（链路质量指示）和CRC状态的两个状态字节可以附加在RX FIFO

### 数据包格式 
数据包的格式可以配置为由以下部分组成： 
- 前导 n 同步字 
- 可选的长度字节 
- 可选的地址字节 
- 净荷 
- 可选的2字节CRC
![数据格式](http://upload-images.jianshu.io/upload_images/1736256-d71997128378e0f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>前导形式是一个交互的0 /1 序 列（01010101...）前导的最小长度是可编程控制的。当启用 TX 时，调制器开始传送前导。当控制数目的前导字节被传送完毕，调制器开始发送同步词汇，然后传送来自 TX FIFO的可利用的数据。若 TX FIFO 为空，调制器将继续传送前导字节，直到第一个字节被写入 TX FIFO。调制器将随后传送同步词汇和数据字节;
前导字节的长度由MDMCFG1.NU_PREAMBLE 值控制。

### 数据包长度
- CC1101 支持恒定长度数据包协议和可变长度协议。
- **可变**或**固定数据包**长度模式能支持的长度可达 255 字节。
- **大于255个字节**的数据包，必须使用**无限数据包长度模式**；
>使用不同长度的配置来支持数据包格式。必须确保在发送前半个或任何字节的时候TX模式不被关闭

#### 固定数据包长度
- 固定数据包长度模式通过设定PKTCTRL0.LENGTH_CONFIG=0来选择。
- 期望的数据包长度通过PKTLEN寄存器来设置，不包括长度字节和可选的CRC；

#### 可变数据包长度
- 可变数据包长度模式，PKTCTRL0.LENGTH_CONFIG=1，数据包长度由同步字后面的第一个字节配置。
- 数据包长度定义为有效载荷，不包括长度字节和可选的CRC。
- PKTLEN用来配置允许接收的最大数据包长度。
- 任何接收的数据包长度大于PKTLEN的值都将被丢弃。

##### 可变长数据包收发逻辑
数据包长度寄存器PKTLEN，在接收和发送时可以重新编程。结合固定数据包长度模式(PKTCTRL0.LENGTH_CONFIG=0)，这使与变长数据包不同的长度配置成为可能。（在可变数据包长度模式下长度字节是同步字节后第一个字节）在接收开始，数据包长度设置为一个大的值。MCU读取足够多的字节来解析数据包中的长度区域。然后依照这个值对PKTLEN进行设置。当数据包处理器中的字节计数器等于PKTLEN寄存器的值时数据包结束。因此，MCU必须在内部计数器达到数据包长度之前确认正确的长度

#### 无限数据包长度模式(大于255个字节)
- PKTCTRL0.LENGTH_CONFIG=2，数据包长度将设置为无限长，发送和接收将持续到手动关闭。

##### 无限数据包长度收发逻辑
- 数据包自动控制寄存器PKTCTRL0，可以在TX和RX期间重新编程。这就使发送和接收数据包长度超过256字节并且仍然使用数据包处理器硬件支持成为可能。
- 在数据包开始时，必须激活无限数据包长度模式（PKTCTRL0.LENGTH_CONFIG=2）。
- 在发送端，PKTLEN寄存器设置为：mod(长度,256)。
- 在接收端，MCU读出足够长度的字节来解析出数据包长度并设置PKTLEN寄存器为:mod(长度,256)。
- 当数据包中还有少于256字节数据，MCU禁止数据包无限长度模式并且激活固定长度模式。
- 当内部字节计数器到PKTLEN时，发送和接收结束。
- （无线进入的状态由TXOFF_MODE 或 RXOFF_MODE决定）自动CRC添加/校验也可以使用（通过设置PKTCTRL0.CRC_EN=1）。

>例子:发送一个600字节的数据包时，MCU必须按照以下执行：
- 设置PKTCTRL0.LENGTH_CONFIG=2。 
-  重新设置PKTLEN寄存器的值为:（600，256）=88. **(600%256 = 88)**
-  至少发送345字节（600-255），例如通过填充64字节 TX FIFO 6次（发送384字节）。 
- 设置PKTCTRL0.LENGTH_CONFIG=0。 
- 当数据包计数器达到88发送完成。一共600字节被发送。 
![600个字节发送](http://upload-images.jianshu.io/upload_images/1736256-d519a90a009de7e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 接收模式下的数据包过滤
CC1101支持三种不同类型的数据包过滤：
- 地址过滤
- 最大长度过滤
- CRC过滤

#### 地址过滤
- 设置PKTCTRL1.ADR_CHK为任意大于0的值使能数据包地址过滤。
- 数据包处理器启动后将比较数据包中的目标地址字节和在ADDR寄存器中设置的节点地址
或者当PKTCTRL1.ADR_CHK=10时的广播地址0x00
以及PKTCTRL1.ADR_CHK=11时的广播地址0x00和0xFF。
如果接收的地址匹配到一个正确地址，数据包被接收并写入到RX FIFO。
如果地址匹配失败，数据包将被丢弃，重新启动接收模式（不管MCSM1.RXOFF_MODE的设置）。 
- 如果当时用无限数据包长度模式和使能地址过滤时接收地址匹配到正确的地址，0xFF将被写入到RX FIFO，其次是地址字节和有效载荷。

#### 最大长度过滤 
在可变数据包模式，PKTCTRL0.LENGTH_CONFIG=1，PKTLEN.PACKET_LENGTH寄存器用来设置最大允许的数据包长度。如果接收的长度字节大于这个值，数据包将被丢弃，重新启动接收模式（不管MCSM1.RXOFF_MODE的设置）。
#### CRC过滤
- 当CRC校验失败时过滤数据包，通过设置PKTCTRL1.CRC_AUTOFLUSH=1使能；
- CRC自动清除功能将在CRC校验失败时清空所有RX FIFO；
- 在自动清空RX FIFO后，下一个状态依赖于MCSM1.RXOFF_MODE的设置；
- 当使用自动清除功能，在可变数据包长度模式下最大数据包长度为63字节，在定长数据包长度模式下是64字节；
- 注意当PKTCTRL1.APPEND_STATUS使能，最大允许数据包长度将减少2个字节，以确保在数据包的结尾附加的2字节的状态字节在RX FIFO中占用的空间；
- 当CRC校验错误以后全部RX FIFO被清空；
- 在接收正确的数据包前之前接收到的数据包必须从FIFO中读出。直到CRC校验正确MCU才从正确的数据包中读取数据；

### 发送模式下的数据包处理
- 需要发送的有效载荷必须写入到TX FIFO；
- 如果使能可变数据包长度第一个字节必须写长度字节；
- 长度字节的值等于数据包的有效载荷（包含可选的地址字节）；
- 如果在接收端使能地址识别，写入到TX FIFO中的第二个字节必须是地址字节；
- 如果使能固定数据包长度，写入到TX FIFO中的第一个字节必须是地址字节（接收端使用地址识别）；
- 调制器将首先发送预置数量的前导字节；
- 如果TX FIFO中有可发送的数据，调制器将发送2字节（可选4字节）同步字，紧接着是TX FIFO中的有效载荷；
- 如果使能CRC，校验时计算TX FIFO中的所有数据，然后跟随有效数据发送2个附加字节；
- 如果在完整的数据包发送完成之前TX FIFO变为空的，无线将进入TXFIFO_UNDERFLOW状态。退出该状态的唯一方法是运行SFTX命令；
- 发送下溢后再向TX FIFO写入数据不能重启TX模式；
- 如果whitening(白化)被使能，同步字后面的所有字节将被whitened。这必须在FEC/Interleaver之前完成。Whitening通过设置PKTCTRL0.WHITE_DATA=1使能；
- 如果FEC/Interleaving(交错器)被使能，同步字后面的所有数据在调制之前将被interleaver 和 FEC编码加密。FEC通过设置MDMCFG1.FEC_EN=1使能；

### 接收模式下的数据包处理
- 在接收模式，解调器和数据包处理器将寻找一个有效的前导和同步字。
- 当找到后，解调器将获得位和字节同步，并将接收第一个有效字节。 
- 如果使能FEC/Interleaver，FEC解码器将开始解码第一个有效字节。Interleaver将在数据被其他任何处理之前解密。 
- 如果使能whitening，在此基础上数据将被de-whitening(反白化)。 
- 当使能可变数据包长度模式时，第一个字节是长度字节。数据包处理器储存该值为数据包长度并且通过该长度字节指示接收的字节数量。
- 如果使用固定数据包长度模式，数据包处理器将接收预置数量的字节。 
- 接下来，数据包处理器可选的检测地址并且只有地址匹配才继续接收。
- 如果使能自动CRC校验，数据包处理器计算CRC并与CRC校验结果相匹配。 
- 在有效载荷的结尾，数据包处理器将可选的写入两个复交数据包状态字节，包括CRC状态、LQI和RSSI

![接收数据包状态字1](http://upload-images.jianshu.io/upload_images/1736256-7786a7bdca8c6dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![接收数据包状态字2](http://upload-images.jianshu.io/upload_images/1736256-116e004500c41ba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### MCU数据包处理
如果在固件中执行一个数据包导向的无线协议，MCU需要知道一个数据包什么时候收到/发送。
加之，超过64字节长度的数据包，当接收时需要读取RX FIFO和当发送时TX FIFO需要重新填充。
这就意味着MCU必须知道有多少个字节可以从RX FIFO中读取或者可以向TX FIFO中写入。
有两种方法可以获得必要的状态信息。
- 中断驱动方法 
  当同步字接收/发送完成或者完整的数据包接收/发送通过设置IOCFGx.GDOx_CFG=0x06，GDO脚可以用在RX和TX中产生一个中断。
此外，
IOCFGx.GDOx_CFG还有两个配置用来产生中断，源于有多少字节在RX FIFO或TX FIFO。
IOCFGx.GDOx_CFG=0x00和IOCFGx.GDOx_CFG=0x01为RX FIFO，
IOCFGx.GDOx_CFG=0x02和IOCFGx.GDOx_CFG=0x03为TX FIFO。

- SPI轮询 
PKTSTATUS可以使用给定的速率查询以获得GDO0和GDO2当前值。
RXBYTES 和 TXBYTES可以使用给定的速率查询以获得RX FIFO或者TX FIFO中的字节数。
合二为一的，RX FIFO和TX FIFO中的字节数量可以从每次头字节、数据字节或命令选通在SPI总线上发送时MISO引脚返回的芯片状态字节读取。 
>**推荐使用中断驱动方法**因为高速率SPI轮询将减小RX的灵敏度。
而且，在Section10.3和CC1101勘误表【4】中，当使用SPI轮询，单一读取PKTSTATUS、 RXBYTES和 TXBYTES有一个小的有限的错误的可能性。
当读取芯片状态字节有同样的问题。 

### RSSI
- RSSI的值时在选择的通道中信号功率级别的估计。
- 这个值基于RX中当前增益的设置和信道中的标准信号等级。 
- 在RX模式，RSSI可以连续的从RSSI状态寄存器读取知道解调器检测到一个同步字（当同步字检测使能）。此时RSSI读取的值将被冻结知道芯片下一次进入RX状态。 
>注意：从无线进入RX模式到在RSSI寄存器检测到一个正确的RSSI值需要一定的时间。查看DN505[15]获得RSSI响应时间估算的详细信息。 
RSSI的值以dBm和1/2 dB给出。
RSSI更新速率，fRSSI 依赖于接收滤波带宽和AGCCTRL0.FILTER_LENGTH。

- 如果使能PKTCTRL1.APPEND_STATUS，数据包最后的RSSI值自动添加到有效载荷后面的第一个附加字节。 
- 从RSSI状态寄存器读出的RSSI值时2个补足的数字。下面的程序可以将RSSI转换为完整的功率级别（RSSI_dBm）。 
1) 读取RSSI状态寄存器 
2) 将读到的数据从16进制数转换到二进制数（RSSI_dec） 
3)  如果RSSI_dec≧128，RSSI_dBm =(RSSI_dec - 256)/2 – RSSI_offset 4）
4 )  如果RSSI_dec＜128，RSSI_dBm =RSSI_dec /2 – RSSI_offset

### 净信道评估（CCA）
- CCA用来显示当前信道是空闲还是繁忙。
- 通过设定IOCFGx.GDOx_CFG=0x09，当前的CCA状态在任何一个GDO引脚都可以查看。 
- MCSM1.CCA_MODE用来选择当确定CCA时使用的模式。 
- 当CC1101在RX状态时给出STX 或 SFSTXON命令选通，仅能在净信道条件完成才能进入TX或FSTXON状态。
- 此外，芯片将仍处于RX状态。如果信道接下来变为可用的，在一个新的命令选通通过SPI接口发送之前，无线不会进入TX或FSTXON状态。这个特性叫做**TX-if-CCA**。
可以编程设置4种CCA条件：
  - 始终（禁止CCA，总是进入TX）
  - 如果RSSI低于门限值 
  -  除非正常接收一个数据包 
  - 以上两个（RSSI低于门限值和没有正常接收一个数据包）

### 链路质量指示（LQI）
- 信号链路质量指示是一个公制的接收信号的当前质量。
- 若 PKTCTRL1.APPEND_STATUS启用，则这个值自动附加在接收数据包的末端。
- 这个值也可从 LQI 状态寄存器上读取。
LQI 由跟随同步词汇的 64 个符号（头 8 个数据包字节）计算得来。LQI 最好用作连接
质量的一个相对的度量，因为这个值决定于调制格式。

### 上电启动序列
- 当电源给电，系统必须复位。
- 通过下面描述的2个序列中的一个来完成，即自动上电复位（POR）或者手动复位。
- 自动上电复位或手动复位之后，推荐转换GDO0引脚上输出的信号。
- 默认设置是以CLK_XOSC/192的频率输出一个时钟信号。
- 然而，为了在TX和RX中优化执行，必须**__GD0/1/2 引脚配置__**中的配置来配置GDO脚

#### 自动POR
CC1101内部包含上电复位电路。最小的需求见表15，完整的上电复位功能必须遵循。当CHIP_RDYn变低内部上电序列完成。在CSn拉低后在SO引脚上可以查看CHIP_RDYn。 
当CC1101复位完成，芯片将进入IDLE状态，晶振开始运行。如果芯片在上电之后有足够的时间让晶振稳定，在捕获CSn变低之后SO引脚将马上变低。如果在复位完成之前CSn被拉低，SO引脚将首先变高，指示晶振没有稳定，变低之前见下图。
![自动POR](http://upload-images.jianshu.io/upload_images/1736256-1dc0e7c8463d0096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 手动复位
CC1101上的其它全部复位时使用SRES命令。通过执行这个命令，所有内部寄存器和状态恢复默认，IDLE状态。手动复位序列如下（图 手动复位）： 
- 设置SCLK=1，SI=0，避免引脚控制模式可能出现的问题。 
-  选通CS低/高。 
- 保持CS为低，然后拉高，至少40us才可以拉低 
- 将CSn拉低等到SO拉低（CHIP_RDYn）。
- 在SI线上发布SRES选通。 
- 当SO再一次拉低，复位完成，芯片进入IDLE状态
![手动复位](http://upload-images.jianshu.io/upload_images/1736256-e692bc860255aa22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注意：以上复位程序只需要在电源给电之后。如果用户在这之后想要复位CC1101，只需要执行SRES命令选通

### 常规用途/ 测试输出控制引脚
3 个数字输出引脚 GDO0 和 GDO1 和 GDO2为常规控制脚。它们的功能分别由
- **IOCFG0.GDO0_CFG**
- **IOCFG1.GDO1_CFG**
- **IOCFG2.GDO3_CFG**
控制;
- GDO1 和在 SPI 接口上的SO 脚是同一脚，因此这个脚上控制的输出在 CSn 高时才有效。
- GDO1 的默认值为 3状态，当 SPI 接口和其它设备一起使用时这是有效的。
- GOO0 的默认值为125kHz-146kHz时钟输出（XOSC 频率除以 192）。当 XOSC 在重启
功率下开启后，使用一个晶体，它就能用来为系统中的 MCU 计时。当 MCU 工作时，通过 IOCFG0.GDO0_CFG，它能改变时钟频率。不会造成时钟波形干扰。
- 对 IOCFG0.GDO0_CFG 寄存器写入值 128（0x80h），芯片内模拟温度传感器启用。然后，GDO0 上的电压与温度成比例
- 如果IOCFGx.GDOx_CFG的设置小于0x20并且IOCFGx_GDOx_INV为0（1），在SLEEP模式GDO0和GDO2将由硬件置0（1），GDO1将有硬件置1（0）。这些信号将由硬件保持知道CHIP_RDYn变低。 
- 如果IOCFGx.GDOx_CFG设置为0x20或更高，GDO引脚在SLEEP状态也工作在设置的状态。例如，如果IOCFG1.GDO1_CFG=0x2E，GDO1在所有状态都是高阻抗。

- - -
GDO0_CFG[5:0] GDO1_CFG[5:0] GDO2_CFG[5:0] | 描述|
----|------|
0(0x00) |与 RX FIFO 关联：当 RX FIFO 在 RXFIFO_THR 上被填充时声明。当 RX FIFO 在RXFIFO THR 之下时被反声明
1(0x01)  |与 RX FIFO 关联：当 RX FIFO 在 RXFIFO_THR 上被填充或到达数据包末端时声明。当RX FIFO 空时被反声明
2(0x02)|与 TX FIFO 关联：当 TX FIFO 在 TXFIFO_THR 上被填充时声明。当 TX FIFO 在TXFIFO THR 之下时被反声明
3(0x03)  |与 TX FIFO 关联：当 TX FIFO 满时声明。当 TX FIFO 在 TXFIFO_THR 之下为空时被反声明
4(0x04) | 当 RX FIFO 已溢出时声明。当 FIFO 被淹没时被反声明
5(0x05) |当 TX FIFO 已下溢时声明。当 FIFO 被淹没时被反声明
6(0x06)  |当同步词汇被送出/收到时声明，在数据包末端时反声明。对 RX，当可选地址检测失败或 RX FIFO 溢出时，引脚被反声明。若 TX FIFO 下溢，这个引脚将同样被反声明
7(0x07)  |当一个数据包被 OK CRC 收到时声明。当第一个字节从 RX FIFO 中读取时反声明
8(0x08)  |前导质量达到。当 PQI 高于控制 PQT 值时声明
9(0x09)  |清理信道评估。当 RSSI 等级低于门限时为高（决定于当前 CCA MODE 设置）
10(0x0A)  |锁定检测器输出
11(0x0B) | 连续时钟。与同步连续模式下的数据同步。数据在下降沿建立，在 SERIAL CLK 上升沿被读取。
12(0x0C) | 连续同步数据输出。同步连续模式时使用。在 SERIAL_CLK 上升沿 MCU 必须读 DO。数据在下降沿由 CC2500 建立
13(0x0D)  |连续透明数据输出。同步连续模式时使用。
14(0x0E)|  载波感应。当 RSSI 等级低于门限时为高
15(0x0F) | CRC OK。上一个 CRC 对比匹配。当进入/重启 RX 模式时清理。
16(0x10) | 保留－测试用
17(0x11) | 保留－测试用
18(0x12) | 保留－测试用
19(0x13) | 保留－测试用
20(0x14) | 保留－测试用
21(0x15) | 保留－测试用
22(0x16) | RX_HARD_DATA[1]。能同RX_SYMBOL_TICK一起使用在交替连续RX输出上。
23(0x17) | RX_HARD_DATA[1]。能同RX_SYMBOL_TICK一起使用在交替连续RX输出上。
24(0x18) | 保留－测试用
25(0x19)  |保留－测试用
26(0x1A) | 保留－测试用
27(0x1B)  |1 时 PA PD.PA 开启，0 时功率降低。能用来控制外部 PA 或 RX/TX 开关
28(0x1C)  |1 时 LNA PD.LNA 开启，0 时功率降低。能用来控制外部 LNA 或 RX/TX 开关
29(0x1D) | RX_SYMBOL_TICK。能同RX_HARD_DATA一起使用在交替连续RX输出上。
30(0x1E) | 保留－测试用
31(0x1F) | 保留－测试用
32(0x20)  |保留－测试用
33(0x21) | 保留－测试用
34(0x22) | 保留－测试用
35(0x23) | 保留－测试用
36(0x24)| 保留－测试用
37(0x25) | 保留－测试用
38(0x26) | 保留－测试用
39(0x27)  |保留－测试用
40(0x28) | 保留－测试用
41(0x29)  |CHIP RDY
42(0x2A)  |保留－测试用
43(0x2B)|  XOSC STABLE
44(0x2C) | 保留－测试用
45(0x2D)  |GDO0 Z EN N。当这个输出为 0 时，GDO0 配置为输入（为连续 TX 数据）
46(0x2E)  |高阻抗（3-状态）
47(0x2F)  |HW 到 0（HW1 同 INV 信号一起完成）
48(0x30) | CLK XOSC/1
49(0x31) | CLK XOSC/1.5
50(0x32) | CLK XOSC/2
51(0x33) | CLK XOSC/3
52(0x34) | CLK XOSC/4
53(0x35) | CLK XOSC/6
54(0x36) | CLK XOSC/8
55(0x37) | CLK XOSC/12
56(0x38) | CLK XOSC/16
57(0x39) | CLK XOSC/24
58(0x3A)|  CLK XOSC/32
59(0x3B)|  CLK XOSC/48
60(0x3C) | CLK XOSC/64
61(0x3D) | CLK XOSC/96
62(0x3E)|  CLK XOSC/128
63(0x3F) | CLK XOSC/192

### 寄存器配置
CC1101的配置通过编程8位寄存器来实现
#### 命令寄存器(12个)
访问这些寄存器将会发起内部状态或模式的改变
- - -
地址|名称|描述
----|----|----
0x30 |SRES |复位芯片
0x31 |SFSTXON |使能和校准频率合成器（如果MCSM0.FS_AUTOCAL=1）。如果在RX(使能CCA)，仅当合成器运行时转到等待状态（RX/TX快速转换）
0x32 |SXOFF |关闭晶振 
0x33 |SCAL| 校准频率合成器并关闭。SCAL可以从IDLE模式执行而不需要设置收到校准模式（MCSM0.FS_AUTOCAL=0）。 
0x34| SRX |使能RX。如果来自IDLE状态并且MCSM0.FS_AUTOCAL=1首先执行校准。 
0x35| STX |在IDLE状态：使能TX。如果MCSM0.FS_AUTOCAL=1首先执行校准。如果在RX状态并使能CCA仅在信道为空时转到TX。 
0x36 |SIDLE| 离开RX/TX模式，关闭频率合成器，如果可用离开WOR。
0x38| SWOR| 如果WORCTRL.RC_PD=0像Section19.5的描述一样开始自动RX轮询序列（WOR）。 
0x39| SPWD |当CSn拉高进入掉电模式。 
0x3A |SFRX |清除RX FIFO缓冲器。只在IDLE 或 RXFIFO_OVERFLOW状态运行SFRX。
0x3B |SFTX| 清除TX FIFO缓冲器。只在IDLE 或 TXFIFO_UNDERFLOW状态运行SFTX。 
0x3C |SWORRST |复位实时时钟到Event1值。 
0x3D |SMOP |无操作，可以用来访问获取芯片状态字节。

#### 配置寄存器
- - -
地址|寄存器|描述|保持在休眠状态中
----|----|----|----
0x00 |IOCFG2 |GDO2输出引脚配置 |是 
0x01 |IOCFG1 |GDO1输出引脚配置 |是
0x02 |IOCFG0 |GDO0输出引脚配置 |是 
0x03 |FIFOTHR| RX FIFO和TX FIFO门限| 是 
0x04 |SYNC1| 同步字，高字节| 是 
0x05 |SYNC0| 同步字，低字节 |是 
0x06 |PKTLEN |数据包长度| 是 
0x07 |PKTCTRL1| 数据包自动控制 |是
0x08 |PKTCTRL0| 数据包自动控制 |是 
0x09 |ADDR |设备地址 |是 
0x0A |CHANNR| 信道号 |是 
0x0B |FSCTRL1| 频率合成器控制 |是 
0x0C |FSCTRL0| 频率合成器控制 |是 
0x0D |FREQ2| 频率控制字，高字节| 是
0x0E |FREQ1 |频率控制字，中间字节| 是 
0x0F |FREQ0 |频率控制字，低字节 |是
0x10| MDMCFG4| Modem配置| 是 
0x11| MDMCFG3 |Modem配置 |是 、
0x12| MDMCFG2 |Modem配置 |是 
0x13| MDMCFG1| Modem配置 |是
0x14| MDMCFG0| Modem配置 |是
0x15 |DEVIATN |Modem背离设定 |是 
0x16 |MCSM2 |主无线控制状态机配置 |是 
0x17 |MCSM1 |主无线控制状态机配置 |是 
0x18 |MCSM0 |主无线控制状态机配置 |是 
0x19 |FOCCFG| 频率偏移补偿配置 |是 
0x1A |BSCFG |位同步配置 |是
0x1B| AGCTRL2| AGC控制 |是 
0x1C| AGCTRL1| AGC控制 |是 
0x1D| AGCTRL0| AGC控制 |是 
0x1E |WOREVT1| 事件0超时高字节| 是 
0x1F| WOREVT0 |事件0超时低字节 |是 
0x20| WORCTRL |WOR控制 |是 
0x21 |FREND1| 前端RX配置 |是 
0x22 |FREND0 |前端TX配置 |是 
0x23 |FSCAL3| 频率合成器校准 |是
0x24 |SCAL2 |频率合成器校准 |是 
0x25 |SCAL1| 频率合成器校准 |是 
0x26 |SCAL0 |频率合成器校准 |是
 0x27| RCCTRL1| RC振荡器配置 |是
 0x28| RCCTRL0 |RC振荡器配置| 是 
0x29| FSTEST |频率合成器校准控制| 否
 0x2A| PTEST| 产品测试 |否 
0x2B |AGCTEST |AGC测试 |否 
0x2C |TEST2 |各方面测试设定 |否 
0x2D |TEST1 |各方面测试设定 |否 
0x2E |TEST0 |各方面测试设定 |否

#### 状态寄存器总览
- - -
地址 |寄存器 |描述
----|----|---
0x30（0xF0）| PARTNUM |CC1101零件号 
0x31（0xF1）| VERSION |当前版本号 
0x32（0xF2） |FREQEST| 频率偏移评估
0x33（0xF3）| LQI| 解调器链路质量估计 
0x34（0xF4） |RSSI |接收信号强度指示 
0x35（0xF5）| MARCSTATE| 控制状态机状态 
0x36（0xF6）| WORTIME1 |WOR定时器高字节
0x37（0xF7）| WORTIME0| WOR定时器低字节 
0x38（0xF8） |PKTSTATUS |当前GDOx状态和数据包状态
0x39（0xF9）| VCO_VC_DAC| PLL校准模块的当前设置 
0x3A（0xFA）| TXBYTES |下溢和TX FIFO中的字节数 
0x3B（0xFB） |RXBYTES |上溢和RX FIFO中的字节数 
0x3C（0xFC） |RCCTRL1_STATUS |上一次RC振荡器校准结果
0x3D（0xFD）| RCCTRL0_STATUS |上一次RC振荡器校准结果
![寄存器总图](http://upload-images.jianshu.io/upload_images/1736256-32d8e78d15cce521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


参考：https://wenku.baidu.com/view/c2b0081b227916888486d769.html